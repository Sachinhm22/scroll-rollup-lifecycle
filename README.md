# How a Transaction Becomes Final on Scroll

## Overview

This document explains, in a clear and linear way, how a single transaction moves through the Scroll rollup pipeline — from submission to finalization on Ethereum.

It is written for new infrastructure engineers who want a system-level mental model of how Scroll connects execution, batching, data availability, and proof verification.

---
## Why This Document Exists

The official Scroll documentation explains execution, batching, and proving in modular sections.  

However, for new infrastructure engineers, it can be difficult to follow a single transaction linearly across system boundaries.

This document provides a lifecycle-first view of the system — focusing on how one transaction moves from submission to finality — without diving into upgrade history or prover internals.

## 1. Transaction Enters the System

A transaction can enter Scroll in two ways:

- A user submits it directly to the **L2 Sequencer** through a Scroll RPC endpoint.
- A user submits it to the **L1 Bridge Contract** on Ethereum (for deposits or enforced transactions).

If submitted on L1:
- The sequencer’s **Sync Service** monitors the L1 bridge.
- It converts the L1 message into a special L2 transaction (`L1MessageTx`).

If submitted directly to L2:
- The transaction enters the sequencer’s **mempool**.

At this stage, the transaction is waiting to be executed.

---

## 2. The Sequencer Executes the Transaction

The L2 Sequencer is responsible for execution and block production.

It contains three core modules:

- **Sync Service** – pulls L1-originated messages.
- **Mempool** – stores user-submitted L2 transactions.
- **Executor** – processes transactions and builds L2 blocks.

The Executor:
- Selects transactions from both the L1 queue and L2 mempool.
- Executes them.
- Produces a new L2 block.

Once included in a block, the transaction becomes **Confirmed**.

---

## 3. Blocks Are Grouped into Chunks and Batches

Scroll reduces on-chain costs by batching transactions in multiple layers.

The Rollup Node monitors newly created L2 blocks.

The grouping structure is:

- **Block** – Basic execution unit.
- **Chunk** – A group of contiguous blocks (unit of proof generation).
- **Batch** – A group of chunks (unit of data commitment and proof verification).

When the batching criteria are met:
- The Rollup Node forms a new batch.
- The batch is prepared for commitment to Ethereum.

---

## 4. Batch Data Is Committed to Ethereum (Data Availability)

The Rollup Relayer submits a **Commit Transaction** to the L1 Rollup Contract.

This transaction:
- Posts compressed batch data to Ethereum.
- Ensures transaction data is publicly available.
- Links the batch to the previous committed batch.

After the commit transaction is finalized on L1:

The transactions inside that batch become **Committed**.

At this point, anyone can reconstruct the L2 state from L1 data.

---

## 5. Validity Proof Is Generated

Scroll uses zero-knowledge proofs to ensure correctness.

After a batch is created:

- Chunk proofs are generated by zkEVM provers.
- An Aggregator Prover combines chunk proofs into a batch proof.
- The proof is stored and prepared for submission.

This proves that all L2 transactions in the batch were executed correctly.

---

## 6. Batch Is Finalized on Ethereum

The Rollup Relayer submits a **Finalize Transaction** to the L1 Rollup Contract.

This transaction:
- Includes the validity proof.
- Includes the new L2 state root.
- Verifies the proof on Ethereum.

If verification succeeds:

The transactions in that batch become **Finalized**.

Finalized transactions are:
- Canonical
- Cryptographically verified
- Fully secured by Ethereum

---

## Lifecycle Summary

### Transaction State Transitions

| Stage       | Trigger                                   | Security Level                  |
|------------|--------------------------------------------|----------------------------------|
| Confirmed  | Included in L2 block by sequencer          | Soft confirmation (L2 consensus) |
| Committed  | Batch data posted to Ethereum (L1 commit)  | Data available on L1             |
| Finalized  | Validity proof verified on Ethereum        | Full Ethereum security           |

## Simplified Lifecycle Diagram
        +-------------------+
        |       User        |
        +---------+---------+
                  |
                  v
        +-------------------+
        |   L2 Sequencer    |
        | (Executes txs &   |
        |  creates blocks)  |
        +---------+---------+
                  |
                  v
        +-------------------+
        |    Rollup Node    |
        | (Forms batches)   |
        +---------+---------+
                  |
                  v
        +-------------------+
        |   L1 Commit Tx    |
        | (Data available)  |
        +---------+---------+
                  |
                  v
        +-------------------+
        | L1 Finalize Tx    |
        | (Proof verified)  |
        +-------------------+

This diagram intentionally abstracts away prover internals to emphasize lifecycle boundaries between execution, data availability, and finality.        

A transaction on Scroll moves through three states:

1. **Confirmed** – Included in an L2 block.
2. **Committed** – Batch data posted to Ethereum.
3. **Finalized** – Validity proof verified on Ethereum.

This separation allows Scroll to:
- Provide fast execution on L2.
- Maintain Ethereum-level security.
- Reduce data and verification costs through batching.

---

## Why This Design Matters

Scroll’s architecture separates:

- Execution (L2 Sequencer)
- Data Availability (Commit on L1)
- Proof Verification (Finalize on L1)

This modular structure enables:
- Scalability through batching
- Security through validity proofs
- Clear state transitions for infrastructure systems

Understanding this lifecycle is foundational for anyone building, indexing, or operating infrastructure on Scroll.
